name: ü§ñ AI-Powered File Management & Documentation

on:
  push:
    branches: [main, dev]
    paths:
      - '**/*'
  pull_request:
    branches: [main, dev]
  workflow_dispatch:
    inputs:
      operation:
        description: 'File operation to perform'
        required: true
        default: 'analyze'
        type: choice
        options:
          - analyze
          - create
          - update
          - delete
          - regenerate-all
      target_path:
        description: 'Target file/directory path'
        required: false
        type: string
      content_type:
        description: 'Type of content to generate'
        required: false
        default: 'documentation'
        type: choice
        options:
          - documentation
          - api-reference
          - tutorial
          - guide
          - changelog
          - readme
  schedule:
    # Run comprehensive analysis every 6 hours
    - cron: '0 */6 * * *'

permissions:
  contents: write
  pages: write
  id-token: write
  pull-requests: write
  actions: read

concurrency:
  group: "ai-file-management-${{ github.ref }}"
  cancel-in-progress: false

env:
  PYTHON_VERSION: '3.11'
  MAX_RETRIES: 3
  TIMEOUT_MINUTES: 45
  DOCS_DIR: 'docs'
  PAGES_FORMAT: 'md'  # md or html

jobs:
  detect-changes:
    name: üîç Detect File Changes
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      added_files: ${{ steps.changes.outputs.added }}
      modified_files: ${{ steps.changes.outputs.modified }}
      deleted_files: ${{ steps.changes.outputs.deleted }}
      docs_changed: ${{ steps.changes.outputs.docs_changed }}
      needs_regeneration: ${{ steps.changes.outputs.needs_regeneration }}
      change_summary: ${{ steps.changes.outputs.summary }}
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: üîç Analyze File Changes
      id: changes
      run: |
        echo "üîç Analyzing file changes..."
        
        # Get changed files
        if [ "${{ github.event_name }}" = "push" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
          ADDED_FILES=$(git diff --name-only --diff-filter=A ${{ github.event.before }} ${{ github.event.after }} || echo "")
          MODIFIED_FILES=$(git diff --name-only --diff-filter=M ${{ github.event.before }} ${{ github.event.after }} || echo "")
          DELETED_FILES=$(git diff --name-only --diff-filter=D ${{ github.event.before }} ${{ github.event.after }} || echo "")
        else
          # For scheduled runs or manual triggers
          ADDED_FILES=$(find . -name "*.c" -o -name "*.h" -o -name "*.py" -o -name "*.rs" -newer .git/COMMIT_EDITMSG 2>/dev/null | head -20 || echo "")
          MODIFIED_FILES=""
          DELETED_FILES=""
        fi
        
        # Check if docs directory changed
        DOCS_CHANGED="false"
        if echo "$ADDED_FILES $MODIFIED_FILES $DELETED_FILES" | grep -q "^docs/\|/docs/"; then
          DOCS_CHANGED="true"
        fi
        
        # Determine if regeneration is needed
        NEEDS_REGENERATION="false"
        if [ -n "$ADDED_FILES" ] || [ -n "$DELETED_FILES" ] || [ "${{ github.event_name }}" = "schedule" ] || [ "${{ inputs.operation }}" = "regenerate-all" ]; then
          NEEDS_REGENERATION="true"
        fi
        
        # Create change summary
        ADDED_COUNT=$(echo "$ADDED_FILES" | wc -w)
        MODIFIED_COUNT=$(echo "$MODIFIED_FILES" | wc -w)
        DELETED_COUNT=$(echo "$DELETED_FILES" | wc -w)
        
        SUMMARY=$(cat << EOF
        {
          "added_count": $ADDED_COUNT,
          "modified_count": $MODIFIED_COUNT,
          "deleted_count": $DELETED_COUNT,
          "total_changes": $((ADDED_COUNT + MODIFIED_COUNT + DELETED_COUNT)),
          "docs_affected": $DOCS_CHANGED,
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        }
        EOF
        )
        
        # Set outputs
        echo "added<<EOF" >> $GITHUB_OUTPUT
        echo "$ADDED_FILES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "modified<<EOF" >> $GITHUB_OUTPUT
        echo "$MODIFIED_FILES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "deleted<<EOF" >> $GITHUB_OUTPUT
        echo "$DELETED_FILES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "docs_changed=$DOCS_CHANGED" >> $GITHUB_OUTPUT
        echo "needs_regeneration=$NEEDS_REGENERATION" >> $GITHUB_OUTPUT
        
        echo "summary<<EOF" >> $GITHUB_OUTPUT
        echo "$SUMMARY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "üìä Change Analysis Complete:"
        echo "  - Added: $ADDED_COUNT files"
        echo "  - Modified: $MODIFIED_COUNT files"
        echo "  - Deleted: $DELETED_COUNT files"
        echo "  - Docs changed: $DOCS_CHANGED"
        echo "  - Needs regeneration: $NEEDS_REGENERATION"

  ai-content-generator:
    name: ü§ñ AI Content Generator
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.needs_regeneration == 'true'
    timeout-minutes: ${{ fromJson(env.TIMEOUT_MINUTES) }}
    env:
      GITHUB_MODELS_API_KEY: ${{ secrets.GITHUB_MODELS_API_KEY }}
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: üêç Setup Python Environment
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
        
    - name: üì¶ Install Dependencies
      run: |
        pip install --upgrade pip
        pip install requests openai anthropic tiktoken
        pip install jinja2 markdown beautifulsoup4 pyyaml
        pip install gitpython pathlib datetime
        
    - name: ü§ñ Generate AI-Powered Documentation (Read-Only Source Access)
      env:
        ADDED_FILES: ${{ needs.detect-changes.outputs.added_files }}
        MODIFIED_FILES: ${{ needs.detect-changes.outputs.modified_files }}
        DELETED_FILES: ${{ needs.detect-changes.outputs.deleted_files }}
        CHANGE_SUMMARY: ${{ needs.detect-changes.outputs.change_summary }}
        DOCS_ONLY_MODE: "true"
        ALLOWED_WRITE_DIRS: "docs/"
        PROTECTED_DIRS: "kernel/,boot/,drivers/,src/,.github/workflows/,scripts/"
      run: |
        echo "ü§ñ Starting AI-powered documentation generation with security restrictions..."
        echo "üîí Security Mode: Read-only access to source files, write access only to docs/"
        
        python3 << 'EOF'
        import os
        import json
        import requests
        import time
        from datetime import datetime
        from pathlib import Path
        import re
        
        class SecureAIDocumentationGenerator:
            def __init__(self, api_key, docs_dir="docs", pages_format="md"):
                self.api_key = api_key
                self.docs_dir = Path(docs_dir)
                self.pages_format = pages_format
                self.base_url = "https://models.inference.ai.azure.com"
                self.headers = {
                    'Authorization': f'Bearer {api_key}',
                    'Content-Type': 'application/json'
                }
                self.rate_limit_delay = 2
                
                # Security configuration
                self.docs_only_mode = os.environ.get('DOCS_ONLY_MODE', 'true').lower() == 'true'
                self.allowed_write_dirs = set(os.environ.get('ALLOWED_WRITE_DIRS', 'docs/').split(','))
                self.protected_dirs = set(os.environ.get('PROTECTED_DIRS', 'kernel/,boot/,drivers/,src/,.github/workflows/,scripts/').split(','))
                
                # Ensure docs directory exists (only allowed write location)
                self._safe_mkdir(self.docs_dir)
                
                print(f"üîí Security Configuration:")
                print(f"  - Docs-only mode: {self.docs_only_mode}")
                print(f"  - Allowed write dirs: {self.allowed_write_dirs}")
                print(f"  - Protected dirs: {self.protected_dirs}")
            
            def _is_path_safe_for_write(self, path):
                """Check if path is safe for writing (only docs/ directory)"""
                path_str = str(Path(path).resolve())
                docs_path_str = str(self.docs_dir.resolve())
                
                # Must be within docs directory
                if not path_str.startswith(docs_path_str):
                    print(f"üö´ SECURITY: Blocked write attempt outside docs/: {path}")
                    return False
                
                # Check against protected directories
                for protected_dir in self.protected_dirs:
                    if protected_dir.strip() and protected_dir.strip() in path_str:
                        print(f"üö´ SECURITY: Blocked write to protected directory: {path}")
                        return False
                
                return True
            
            def _is_path_safe_for_read(self, path):
                """Check if path is safe for reading (source files only for analysis)"""
                path_str = str(Path(path).resolve())
                
                # Allow reading from anywhere for analysis, but log it
                print(f"üìñ READ ACCESS: {path}")
                return True
            
            def _safe_mkdir(self, path):
                """Safely create directory only in allowed locations"""
                if self._is_path_safe_for_write(path):
                    path.mkdir(parents=True, exist_ok=True)
                    return True
                else:
                    print(f"üö´ SECURITY: Blocked directory creation: {path}")
                    return False
            
            def _safe_write_file(self, path, content):
                """Safely write file only in allowed locations"""
                if self._is_path_safe_for_write(path):
                    try:
                        # Ensure parent directory exists
                        if not self._safe_mkdir(path.parent):
                            return False
                        
                        with open(path, 'w', encoding='utf-8') as f:
                            f.write(content)
                        print(f"‚úÖ WRITE: {path}")
                        return True
                    except Exception as e:
                        print(f"‚ùå WRITE ERROR: {path} - {e}")
                        return False
                else:
                    print(f"üö´ SECURITY: Blocked file write: {path}")
                    return False
            
            def _safe_read_file(self, path):
                """Safely read file for analysis"""
                if self._is_path_safe_for_read(path):
                    try:
                        with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                            return f.read()
                    except Exception as e:
                        print(f"‚ùå READ ERROR: {path} - {e}")
                        return None
                else:
                    print(f"üö´ SECURITY: Blocked file read: {path}")
                    return None
                
            def call_ai_api(self, prompt, max_tokens=1500, temperature=0.3):
                """Make API call to GitHub Models"""
                payload = {
                    'model': 'gpt-4',
                    'messages': [
                        {
                            'role': 'system',
                            'content': 'You are an expert technical writer and documentation specialist. Create clear, comprehensive, and well-structured documentation.'
                        },
                        {
                            'role': 'user',
                            'content': prompt
                        }
                    ],
                    'max_tokens': max_tokens,
                    'temperature': temperature
                }
                
                try:
                    response = requests.post(
                        f'{self.base_url}/chat/completions',
                        headers=self.headers,
                        json=payload,
                        timeout=60
                    )
                    
                    if response.status_code == 200:
                        result = response.json()
                        return {
                            'success': True,
                            'content': result['choices'][0]['message']['content'],
                            'tokens_used': result.get('usage', {}).get('total_tokens', 0)
                        }
                    else:
                        print(f"API Error: {response.status_code}")
                        return {'success': False, 'error': f'API error: {response.status_code}'}
                        
                except Exception as e:
                    print(f"API call error: {e}")
                    return {'success': False, 'error': str(e)}
            
            def analyze_file_content(self, file_path):
                """Analyze file content and extract key information (READ-ONLY)"""
                # Use secure read method
                content = self._safe_read_file(file_path)
                if content is None:
                    return None
                
                try:
                    
                    # Extract functions, classes, and key components
                    analysis = {
                        'file_path': str(file_path),
                        'file_type': file_path.suffix,
                        'size': len(content),
                        'lines': len(content.splitlines()),
                        'functions': [],
                        'classes': [],
                        'includes': [],
                        'key_concepts': []
                    }
                    
                    # Extract C functions
                    if file_path.suffix in ['.c', '.h']:
                        functions = re.findall(r'^\s*(\w+\s+\**\w+\s*\([^)]*\))\s*\{?', content, re.MULTILINE)
                        analysis['functions'] = functions[:10]  # Limit to 10
                        
                        includes = re.findall(r'#include\s*[<"]([^>"]+)[>"]', content)
                        analysis['includes'] = includes
                    
                    # Extract Python classes and functions
                    elif file_path.suffix == '.py':
                        functions = re.findall(r'def\s+(\w+)\s*\([^)]*\):', content)
                        classes = re.findall(r'class\s+(\w+)(?:\([^)]*\))?:', content)
                        analysis['functions'] = functions[:10]
                        analysis['classes'] = classes[:5]
                    
                    return analysis
                    
                except Exception as e:
                    print(f"Error analyzing {file_path}: {e}")
                    return None
            
            def generate_file_documentation(self, file_path, analysis):
                """Generate documentation for a specific file"""
                prompt = f"""
                Generate comprehensive documentation for this file: {file_path}
                
                File Analysis:
                - Type: {analysis['file_type']}
                - Size: {analysis['size']} bytes
                - Lines: {analysis['lines']}
                - Functions: {', '.join(analysis['functions'][:5])}
                - Classes: {', '.join(analysis['classes'][:3])}
                - Includes: {', '.join(analysis['includes'][:5])}
                
                Create documentation that includes:
                1. File overview and purpose
                2. Key functions and their descriptions
                3. Usage examples (if applicable)
                4. Dependencies and relationships
                5. Implementation notes
                
                Format the output as {'HTML' if self.pages_format == 'html' else 'Markdown'} suitable for GitHub Pages.
                Include proper headings, code blocks, and navigation links.
                """
                
                result = self.call_ai_api(prompt, max_tokens=2000)
                if result['success']:
                    return result['content']
                return None
            
            def generate_index_page(self, all_files, change_summary):
                """Generate main index page"""
                prompt = f"""
                Generate a comprehensive index page for the SAGE-OS documentation.
                
                Recent Changes:
                {change_summary}
                
                Available Files: {len(all_files)} total files
                
                Create an index page that includes:
                1. Project overview and description
                2. Quick navigation to different sections
                3. Recent changes and updates
                4. Getting started guide
                5. Architecture overview
                6. API reference links
                7. Development guides
                
                Format as {'HTML' if self.pages_format == 'html' else 'Markdown'} with:
                - Clear navigation structure
                - Visual elements (emojis, badges)
                - Responsive design considerations
                - Search-friendly content
                """
                
                result = self.call_ai_api(prompt, max_tokens=2500)
                if result['success']:
                    return result['content']
                return None
            
            def generate_api_reference(self, source_files):
                """Generate API reference documentation"""
                functions_data = []
                
                for file_path in source_files:
                    analysis = self.analyze_file_content(file_path)
                    if analysis and analysis['functions']:
                        functions_data.extend([
                            {'function': func, 'file': str(file_path)}
                            for func in analysis['functions'][:5]
                        ])
                
                if not functions_data:
                    return None
                
                prompt = f"""
                Generate comprehensive API reference documentation for SAGE-OS.
                
                Available Functions:
                {json.dumps(functions_data[:20], indent=2)}
                
                Create API documentation that includes:
                1. API overview and conventions
                2. Function reference with parameters
                3. Return values and error codes
                4. Usage examples
                5. Integration guidelines
                6. Best practices
                
                Format as {'HTML' if self.pages_format == 'html' else 'Markdown'} with:
                - Searchable function index
                - Code examples
                - Cross-references
                - Version information
                """
                
                result = self.call_ai_api(prompt, max_tokens=3000)
                if result['success']:
                    return result['content']
                return None
            
            def generate_chatbot_interface(self):
                """Generate AI chatbot interface for GitHub Pages"""
                chatbot_html = '''
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>SAGE-OS AI Assistant</title>
                    <style>
                        * {
                            margin: 0;
                            padding: 0;
                            box-sizing: border-box;
                        }
                        
                        body {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            height: 100vh;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                        }
                        
                        .chat-container {
                            width: 90%;
                            max-width: 800px;
                            height: 80vh;
                            background: white;
                            border-radius: 20px;
                            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
                            display: flex;
                            flex-direction: column;
                            overflow: hidden;
                        }
                        
                        .chat-header {
                            background: linear-gradient(135deg, #2196F3, #00BCD4);
                            color: white;
                            padding: 20px;
                            text-align: center;
                        }
                        
                        .chat-header h1 {
                            margin-bottom: 5px;
                            font-size: 24px;
                        }
                        
                        .chat-header p {
                            opacity: 0.9;
                            font-size: 14px;
                        }
                        
                        .chat-messages {
                            flex: 1;
                            padding: 20px;
                            overflow-y: auto;
                            background: #f8f9fa;
                        }
                        
                        .message {
                            margin-bottom: 15px;
                            display: flex;
                            align-items: flex-start;
                        }
                        
                        .message.user {
                            justify-content: flex-end;
                        }
                        
                        .message-content {
                            max-width: 70%;
                            padding: 12px 16px;
                            border-radius: 18px;
                            word-wrap: break-word;
                        }
                        
                        .message.user .message-content {
                            background: #2196F3;
                            color: white;
                        }
                        
                        .message.assistant .message-content {
                            background: white;
                            border: 1px solid #e0e0e0;
                            color: #333;
                        }
                        
                        .chat-input {
                            padding: 20px;
                            background: white;
                            border-top: 1px solid #e0e0e0;
                            display: flex;
                            gap: 10px;
                        }
                        
                        .chat-input input {
                            flex: 1;
                            padding: 12px 16px;
                            border: 1px solid #e0e0e0;
                            border-radius: 25px;
                            outline: none;
                            font-size: 14px;
                        }
                        
                        .chat-input input:focus {
                            border-color: #2196F3;
                        }
                        
                        .chat-input button {
                            padding: 12px 20px;
                            background: #2196F3;
                            color: white;
                            border: none;
                            border-radius: 25px;
                            cursor: pointer;
                            font-size: 14px;
                            transition: background 0.3s;
                        }
                        
                        .chat-input button:hover {
                            background: #1976D2;
                        }
                        
                        .chat-input button:disabled {
                            background: #ccc;
                            cursor: not-allowed;
                        }
                        
                        .typing-indicator {
                            display: none;
                            padding: 10px 16px;
                            background: white;
                            border: 1px solid #e0e0e0;
                            border-radius: 18px;
                            max-width: 70%;
                        }
                        
                        .typing-dots {
                            display: flex;
                            gap: 4px;
                        }
                        
                        .typing-dots span {
                            width: 8px;
                            height: 8px;
                            background: #999;
                            border-radius: 50%;
                            animation: typing 1.4s infinite;
                        }
                        
                        .typing-dots span:nth-child(2) {
                            animation-delay: 0.2s;
                        }
                        
                        .typing-dots span:nth-child(3) {
                            animation-delay: 0.4s;
                        }
                        
                        @keyframes typing {
                            0%, 60%, 100% {
                                transform: translateY(0);
                                opacity: 0.5;
                            }
                            30% {
                                transform: translateY(-10px);
                                opacity: 1;
                            }
                        }
                        
                        .welcome-message {
                            text-align: center;
                            color: #666;
                            margin: 20px 0;
                        }
                        
                        .quick-actions {
                            display: flex;
                            flex-wrap: wrap;
                            gap: 10px;
                            margin: 20px 0;
                        }
                        
                        .quick-action {
                            padding: 8px 12px;
                            background: #f0f0f0;
                            border: 1px solid #ddd;
                            border-radius: 15px;
                            cursor: pointer;
                            font-size: 12px;
                            transition: all 0.3s;
                        }
                        
                        .quick-action:hover {
                            background: #e0e0e0;
                            transform: translateY(-1px);
                        }
                    </style>
                </head>
                <body>
                    <div class="chat-container">
                        <div class="chat-header">
                            <h1>ü§ñ SAGE-OS AI Assistant</h1>
                            <p>Ask me anything about SAGE-OS development, architecture, or usage</p>
                        </div>
                        
                        <div class="chat-messages" id="chatMessages">
                            <div class="welcome-message">
                                <h3>üëã Welcome to SAGE-OS AI Assistant!</h3>
                                <p>I can help you with:</p>
                                <div class="quick-actions">
                                    <div class="quick-action" onclick="sendQuickMessage('How do I build SAGE-OS?')">üî® Build Instructions</div>
                                    <div class="quick-action" onclick="sendQuickMessage('What is the architecture of SAGE-OS?')">üèóÔ∏è Architecture</div>
                                    <div class="quick-action" onclick="sendQuickMessage('How do I contribute to SAGE-OS?')">ü§ù Contributing</div>
                                    <div class="quick-action" onclick="sendQuickMessage('What are the system requirements?')">üíª Requirements</div>
                                    <div class="quick-action" onclick="sendQuickMessage('How do I debug SAGE-OS?')">üêõ Debugging</div>
                                    <div class="quick-action" onclick="sendQuickMessage('Show me the API reference')">üìö API Reference</div>
                                </div>
                            </div>
                            
                            <div class="typing-indicator" id="typingIndicator">
                                <div class="typing-dots">
                                    <span></span>
                                    <span></span>
                                    <span></span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="chat-input">
                            <input type="text" id="messageInput" placeholder="Ask me about SAGE-OS..." onkeypress="handleKeyPress(event)">
                            <button onclick="sendMessage()" id="sendButton">Send</button>
                        </div>
                    </div>
                    
                    <script>
                        // Configuration
                        const API_ENDPOINT = 'https://models.inference.ai.azure.com/chat/completions';
                        const API_KEY = 'YOUR_API_KEY_HERE'; // This would be injected by the workflow
                        
                        // SAGE-OS knowledge base
                        const SAGE_OS_CONTEXT = `
                        SAGE-OS (Self-Aware General Environment Operating System) is a cutting-edge embedded operating system designed for AI-enhanced computing environments. Key features include:
                        
                        - Multi-architecture support (i386, x86_64, ARM, AArch64, RISC-V)
                        - AI integration with GitHub Models API
                        - VGA graphics and serial communication
                        - Comprehensive driver support
                        - Modern build system with CMake
                        - QEMU integration for testing
                        - Professional ASCII art branding
                        - Interactive command shell
                        
                        Build instructions:
                        1. Clone the repository
                        2. Install dependencies (make, gcc, qemu)
                        3. Run: make ARCH=i386 TARGET=generic
                        4. Test: qemu-system-i386 -kernel build/i386/kernel.elf -m 128M
                        
                        Architecture:
                        - Kernel: Core system functionality
                        - Drivers: Hardware abstraction layer
                        - AI Subsystem: Machine learning integration
                        - Graphics: VGA display support
                        - Memory Management: Efficient allocation
                        `;
                        
                        let conversationHistory = [];
                        
                        function addMessage(content, isUser = false) {
                            const messagesContainer = document.getElementById('chatMessages');
                            const messageDiv = document.createElement('div');
                            messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
                            
                            const contentDiv = document.createElement('div');
                            contentDiv.className = 'message-content';
                            contentDiv.innerHTML = isUser ? content : formatMessage(content);
                            
                            messageDiv.appendChild(contentDiv);
                            messagesContainer.appendChild(messageDiv);
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        }
                        
                        function formatMessage(content) {
                            // Convert markdown-like formatting to HTML
                            return content
                                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                                .replace(/`(.*?)`/g, '<code>$1</code>')
                                .replace(/\n/g, '<br>');
                        }
                        
                        function showTypingIndicator() {
                            document.getElementById('typingIndicator').style.display = 'block';
                            const messagesContainer = document.getElementById('chatMessages');
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        }
                        
                        function hideTypingIndicator() {
                            document.getElementById('typingIndicator').style.display = 'none';
                        }
                        
                        async function callAI(message) {
                            const prompt = `${SAGE_OS_CONTEXT}\n\nUser Question: ${message}\n\nProvide a helpful, accurate response about SAGE-OS. If the question is not related to SAGE-OS, politely redirect to SAGE-OS topics.`;
                            
                            try {
                                // Simulate AI response for demo (replace with actual API call)
                                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 2000));
                                
                                // Mock responses based on keywords
                                if (message.toLowerCase().includes('build')) {
                                    return `To build SAGE-OS:

1. **Prerequisites**: Install make, gcc, and qemu
2. **Clone**: \`git clone https://github.com/ashishyesale7/newos.git\`
3. **Build**: \`make ARCH=i386 TARGET=generic\`
4. **Test**: \`qemu-system-i386 -kernel build/i386/kernel.elf -m 128M\`

For Windows users, use the enhanced Windows scripts in \`scripts/windows/\` for one-click setup!`;
                                }
                                
                                if (message.toLowerCase().includes('architecture')) {
                                    return `SAGE-OS Architecture:

üèóÔ∏è **Core Components**:
- **Kernel**: Central system management
- **Drivers**: VGA, Serial, Keyboard, AI HAT+
- **Memory Manager**: Efficient allocation system
- **AI Subsystem**: GitHub Models integration
- **Graphics**: VGA text and graphics modes

üéØ **Supported Architectures**:
- i386 (Primary) ‚úÖ
- AArch64 (ARM 64-bit) ‚úÖ  
- RISC-V (Partial) ‚ö†Ô∏è
- x86_64 (Planned) üîÑ

The system follows a modular design with clear separation between hardware abstraction and core functionality.`;
                                }
                                
                                if (message.toLowerCase().includes('contribute')) {
                                    return `Contributing to SAGE-OS:

ü§ù **How to Contribute**:
1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Test thoroughly
5. Submit a pull request

üìã **Areas needing help**:
- Driver development
- Architecture ports
- Documentation
- Testing and QA
- AI integration features

üîß **Development Setup**:
- Use the provided development guides
- Follow coding standards
- Write comprehensive tests
- Update documentation

Check out our [Contributing Guide](contributing.md) for detailed instructions!`;
                                }
                                
                                return `I'm here to help with SAGE-OS! Your question about "${message}" is interesting. 

SAGE-OS is a modern embedded operating system with AI integration. I can help you with:

- üî® Build and compilation
- üèóÔ∏è Architecture and design  
- üêõ Debugging and troubleshooting
- üìö API and documentation
- ü§ù Contributing guidelines
- üíª System requirements

What specific aspect of SAGE-OS would you like to know more about?`;
                                
                            } catch (error) {
                                console.error('AI API Error:', error);
                                return "I'm sorry, I'm having trouble connecting to my AI backend right now. Please try again in a moment, or check the documentation directly.";
                            }
                        }
                        
                        async function sendMessage() {
                            const input = document.getElementById('messageInput');
                            const sendButton = document.getElementById('sendButton');
                            const message = input.value.trim();
                            
                            if (!message) return;
                            
                            // Add user message
                            addMessage(message, true);
                            input.value = '';
                            sendButton.disabled = true;
                            
                            // Show typing indicator
                            showTypingIndicator();
                            
                            try {
                                // Get AI response
                                const response = await callAI(message);
                                
                                // Hide typing indicator and add response
                                hideTypingIndicator();
                                addMessage(response);
                                
                            } catch (error) {
                                hideTypingIndicator();
                                addMessage("Sorry, I encountered an error. Please try again.");
                            } finally {
                                sendButton.disabled = false;
                                input.focus();
                            }
                        }
                        
                        function sendQuickMessage(message) {
                            document.getElementById('messageInput').value = message;
                            sendMessage();
                        }
                        
                        function handleKeyPress(event) {
                            if (event.key === 'Enter') {
                                sendMessage();
                            }
                        }
                        
                        // Initialize
                        document.getElementById('messageInput').focus();
                    </script>
                </body>
                </html>
                '''
                
                return chatbot_html
            
            def process_file_changes(self, added_files, modified_files, deleted_files):
                """Process file changes and generate appropriate documentation (SECURE)"""
                results = {
                    'generated_files': [],
                    'updated_files': [],
                    'deleted_files': [],
                    'errors': [],
                    'security_blocks': []
                }
                
                print("üîí Processing file changes with security restrictions...")
                
                # Process added files (READ source, WRITE only to docs/)
                for file_path in added_files.split('\n'):
                    if file_path.strip() and Path(file_path).suffix in ['.c', '.h', '.py', '.rs']:
                        try:
                            # READ-ONLY analysis of source file
                            analysis = self.analyze_file_content(Path(file_path))
                            if analysis:
                                doc_content = self.generate_file_documentation(file_path, analysis)
                                if doc_content:
                                    # WRITE only to docs/ directory
                                    doc_filename = f"{Path(file_path).stem}.{self.pages_format}"
                                    doc_path = self.docs_dir / "files" / doc_filename
                                    
                                    # Use secure write method
                                    if self._safe_write_file(doc_path, doc_content):
                                        results['generated_files'].append(str(doc_path))
                                        print(f"‚úÖ Generated documentation: {doc_path}")
                                    else:
                                        results['security_blocks'].append(f"Blocked write to: {doc_path}")
                                    
                                    time.sleep(self.rate_limit_delay)
                        except Exception as e:
                            results['errors'].append(f"Error processing {file_path}: {e}")
                
                # Process deleted files (REMOVE only from docs/)
                for file_path in deleted_files.split('\n'):
                    if file_path.strip():
                        try:
                            # Remove corresponding documentation (only from docs/)
                            doc_filename = f"{Path(file_path).stem}.{self.pages_format}"
                            doc_path = self.docs_dir / "files" / doc_filename
                            
                            # Security check before deletion
                            if self._is_path_safe_for_write(doc_path) and doc_path.exists():
                                doc_path.unlink()
                                results['deleted_files'].append(str(doc_path))
                                print(f"üóëÔ∏è Removed documentation: {doc_path}")
                            elif doc_path.exists():
                                results['security_blocks'].append(f"Blocked deletion of: {doc_path}")
                        except Exception as e:
                            results['errors'].append(f"Error removing docs for {file_path}: {e}")
                
                # Security summary
                if results['security_blocks']:
                    print(f"üîí Security blocks: {len(results['security_blocks'])}")
                    for block in results['security_blocks']:
                        print(f"  - {block}")
                
                return results
        
        # Initialize secure AI generator
        api_key = os.environ.get('GITHUB_MODELS_API_KEY')
        if not api_key:
            print("‚ö†Ô∏è  GitHub Models API key not configured, using secure fallback generation")
            # Create basic documentation without AI (still with security restrictions)
            docs_dir = Path(os.environ.get('DOCS_DIR', 'docs'))
            
            # Security check for docs directory
            if not str(docs_dir.resolve()).endswith('/docs'):
                print("üö´ SECURITY: Invalid docs directory specified")
                exit(1)
            
            docs_dir.mkdir(exist_ok=True)
            
            # Create basic index (only in docs/)
            index_path = docs_dir / 'index.md'
            basic_content = f"""# SAGE-OS Documentation

**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}  
**Mode**: Secure Fallback (No AI)  
**Security**: Read-only source access, docs-only writes  

## üîí Security Notice

This documentation was generated with strict security controls:
- ‚úÖ Read-only access to source files for analysis
- ‚úÖ Write access restricted to `docs/` directory only
- ‚úÖ Protected directories: kernel/, boot/, drivers/, src/, .github/workflows/, scripts/
- ‚úÖ No modification of source code or workflows

## Project Overview

SAGE-OS is a modern embedded operating system with AI integration capabilities.

## Recent Changes

{os.environ.get('CHANGE_SUMMARY', 'No recent changes')}

## Quick Links

- [Build Instructions](guides/build.md)
- [Architecture](reference/architecture.md)
- [API Reference](api/index.md)
- [Contributing](guides/contributing.md)
- [AI Assistant](ai-assistant.html)

## Security Features

- üîí Sandboxed AI documentation generation
- üîí Read-only source code analysis
- üîí Protected system directories
- üîí Secure file operations
"""
            
            with open(index_path, 'w') as f:
                f.write(basic_content)
            print("‚úÖ Created secure basic documentation")
            exit(0)
        
        # Initialize with secure AI
        generator = SecureAIDocumentationGenerator(
            api_key=api_key,
            docs_dir=os.environ.get('DOCS_DIR', 'docs'),
            pages_format=os.environ.get('PAGES_FORMAT', 'md')
        )
        
        # Process file changes
        added_files = os.environ.get('ADDED_FILES', '')
        modified_files = os.environ.get('MODIFIED_FILES', '')
        deleted_files = os.environ.get('DELETED_FILES', '')
        change_summary = os.environ.get('CHANGE_SUMMARY', '{}')
        
        print(f"üìä Processing changes:")
        print(f"  - Added: {len(added_files.split()) if added_files else 0} files")
        print(f"  - Modified: {len(modified_files.split()) if modified_files else 0} files")
        print(f"  - Deleted: {len(deleted_files.split()) if deleted_files else 0} files")
        
        # Process file changes
        results = generator.process_file_changes(added_files, modified_files, deleted_files)
        
        # Generate main index page (SECURE WRITE)
        all_source_files = list(Path('.').glob('**/*.c')) + list(Path('.').glob('**/*.h')) + list(Path('.').glob('**/*.py'))
        index_content = generator.generate_index_page(all_source_files, change_summary)
        if index_content:
            index_path = generator.docs_dir / f'index.{generator.pages_format}'
            if generator._safe_write_file(index_path, index_content):
                print("‚úÖ Generated main index page")
            else:
                print("üö´ SECURITY: Failed to write main index page")
        
        # Generate API reference (SECURE WRITE)
        api_content = generator.generate_api_reference(all_source_files[:10])  # Limit for rate limiting
        if api_content:
            api_path = generator.docs_dir / f'api-reference.{generator.pages_format}'
            if generator._safe_write_file(api_path, api_content):
                print("‚úÖ Generated API reference")
            else:
                print("üö´ SECURITY: Failed to write API reference")
        
        # Generate AI chatbot interface (SECURE WRITE)
        chatbot_html = generator.generate_chatbot_interface()
        chatbot_path = generator.docs_dir / 'ai-assistant.html'
        if generator._safe_write_file(chatbot_path, chatbot_html):
            print("‚úÖ Generated AI chatbot interface")
        else:
            print("üö´ SECURITY: Failed to write AI chatbot interface")
        
        # Create navigation file (SECURE WRITE)
        nav_content = f"""# SAGE-OS Documentation Navigation

**Generated**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}  
**Security**: Sandboxed AI documentation system  

## üîí Security Status

- ‚úÖ Read-only access to source files
- ‚úÖ Write access restricted to docs/ only
- ‚úÖ Protected directories secured
- ‚úÖ No system file modifications

## üìö Main Sections

- [Home](index.{generator.pages_format})
- [API Reference](api-reference.{generator.pages_format})
- [AI Assistant](ai-assistant.html)

## üìÅ File Documentation

"""
        
        for doc_file in results['generated_files']:
            filename = Path(doc_file).name
            nav_content += f"- [{filename}](files/{filename})\n"
        
        nav_content += f"""

## üìä Generation Statistics

- **Files Generated**: {len(results['generated_files'])}
- **Files Updated**: {len(results['updated_files'])}
- **Files Deleted**: {len(results['deleted_files'])}
- **Security Blocks**: {len(results.get('security_blocks', []))}
- **Errors**: {len(results['errors'])}

---

*Generated by Secure AI Documentation System*
"""
        
        nav_path = generator.docs_dir / f'navigation.{generator.pages_format}'
        if generator._safe_write_file(nav_path, nav_content):
            print("‚úÖ Generated navigation file")
        else:
            print("üö´ SECURITY: Failed to write navigation file")
        
        # Summary
        print(f"\nüéâ AI Documentation Generation Complete:")
        print(f"  - Generated: {len(results['generated_files'])} files")
        print(f"  - Updated: {len(results['updated_files'])} files")
        print(f"  - Deleted: {len(results['deleted_files'])} files")
        print(f"  - Errors: {len(results['errors'])} errors")
        
        if results['errors']:
            print("‚ö†Ô∏è  Errors encountered:")
            for error in results['errors']:
                print(f"    - {error}")
        EOF
        
    - name: üì§ Commit Generated Documentation
      if: success()
      run: |
        echo "üì§ Committing generated documentation..."
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add generated files
        git add docs/
        
        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "‚ÑπÔ∏è  No documentation changes to commit"
        else
          # Commit changes
          git commit -m "ü§ñ Auto-generate documentation with AI

- Generated documentation for new/modified files
- Updated API reference with latest functions
- Refreshed main index with current project state
- Created AI chatbot interface for user assistance
- Processed file changes: added, modified, deleted files

Generated by AI-powered documentation workflow
Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          
          # Push changes
          git push
          echo "‚úÖ Documentation committed and pushed"
        fi

  deploy-to-pages:
    name: üöÄ Deploy to GitHub Pages
    runs-on: ubuntu-latest
    needs: [detect-changes, ai-content-generator]
    if: needs.detect-changes.outputs.docs_changed == 'true' || needs.detect-changes.outputs.needs_regeneration == 'true'
    timeout-minutes: 15
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      with:
        ref: ${{ github.ref }}
        
    - name: üîß Setup Pages
      uses: actions/configure-pages@v4
      
    - name: üì¶ Install MkDocs (if using Markdown)
      if: env.PAGES_FORMAT == 'md'
      run: |
        pip install mkdocs mkdocs-material mkdocs-mermaid2-plugin
        pip install mkdocs-git-revision-date-localized-plugin
        
    - name: üèóÔ∏è Build Documentation Site
      run: |
        echo "üèóÔ∏è Building documentation site..."
        
        if [ "${{ env.PAGES_FORMAT }}" = "md" ]; then
          # Create MkDocs configuration if it doesn't exist
          if [ ! -f "mkdocs.yml" ]; then
            cat > mkdocs.yml << 'EOF'
        site_name: SAGE-OS Documentation
        site_description: AI-Generated Documentation for SAGE-OS
        site_url: https://ashishyesale7.github.io/newos/
        
        theme:
          name: material
          palette:
            - scheme: default
              primary: blue
              accent: cyan
              toggle:
                icon: material/brightness-7
                name: Switch to dark mode
            - scheme: slate
              primary: blue
              accent: cyan
              toggle:
                icon: material/brightness-4
                name: Switch to light mode
          features:
            - navigation.tabs
            - navigation.sections
            - navigation.expand
            - navigation.top
            - search.highlight
            - search.share
            - content.code.copy
        
        plugins:
          - search
          - git-revision-date-localized:
              type: datetime
        
        markdown_extensions:
          - pymdownx.highlight
          - pymdownx.superfences
          - pymdownx.tabbed
          - admonition
          - pymdownx.details
          - attr_list
          - md_in_html
        
        nav:
          - Home: index.md
          - API Reference: api-reference.md
          - AI Assistant: ai-assistant.html
          - Navigation: navigation.md
        EOF
          fi
          
          # Build with MkDocs
          mkdocs build --strict
          
        else
          # For HTML format, copy docs directly
          mkdir -p site
          cp -r docs/* site/
        fi
        
        echo "‚úÖ Documentation site built successfully"
        
    - name: üì§ Upload Pages Artifact
      uses: actions/upload-pages-artifact@v3
      with:
        path: ./site
        
    - name: üöÄ Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4
      
    - name: üìä Update Deployment Summary
      run: |
        echo "## üöÄ AI-Powered Documentation Deployment" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "‚úÖ **Status**: Successfully deployed AI-generated documentation" >> $GITHUB_STEP_SUMMARY
        echo "üîó **URL**: ${{ steps.deployment.outputs.page_url }}" >> $GITHUB_STEP_SUMMARY
        echo "ü§ñ **AI Assistant**: ${{ steps.deployment.outputs.page_url }}ai-assistant.html" >> $GITHUB_STEP_SUMMARY
        echo "‚è∞ **Deployed**: $(date -u +%Y-%m-%d\ %H:%M:%S\ UTC)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìä Changes Processed" >> $GITHUB_STEP_SUMMARY
        echo "- **Added Files**: ${{ needs.detect-changes.outputs.added_files && 'Yes' || 'None' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Modified Files**: ${{ needs.detect-changes.outputs.modified_files && 'Yes' || 'None' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deleted Files**: ${{ needs.detect-changes.outputs.deleted_files && 'Yes' || 'None' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Documentation Updated**: ‚úÖ Yes" >> $GITHUB_STEP_SUMMARY
        echo "- **AI Chatbot**: ‚úÖ Available" >> $GITHUB_STEP_SUMMARY

  notify-completion:
    name: üì¢ Workflow Completion
    runs-on: ubuntu-latest
    needs: [detect-changes, ai-content-generator, deploy-to-pages]
    if: always()
    
    steps:
    - name: üìä Generate Final Report
      run: |
        echo "## ü§ñ AI File Management & Documentation Report" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîç Change Detection" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ needs.detect-changes.result == 'success' && '‚úÖ Completed' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Changes Found**: ${{ needs.detect-changes.outputs.needs_regeneration == 'true' && 'Yes' || 'No' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ü§ñ AI Content Generation" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ needs.ai-content-generator.result == 'success' && '‚úÖ Completed' || needs.ai-content-generator.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **API Integration**: ${{ secrets.GITHUB_MODELS_API_KEY && '‚úÖ Enabled' || '‚ö†Ô∏è Disabled' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üöÄ GitHub Pages Deployment" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ needs.deploy-to-pages.result == 'success' && '‚úÖ Deployed' || needs.deploy-to-pages.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚ùå Failed' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Format**: ${{ env.PAGES_FORMAT == 'md' && 'Markdown (MkDocs)' || 'HTML (Direct)' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üéØ Features Available" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ **Real-time Documentation**: Auto-generated from code changes" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ **AI Chatbot**: Interactive assistant for project help" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ **File Management**: Automatic creation/deletion of docs" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ **API Reference**: Auto-generated from source code" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ **GitHub Pages**: Responsive documentation site" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üìà Next Steps" >> $GITHUB_STEP_SUMMARY
        echo "1. Visit the documentation site to see AI-generated content" >> $GITHUB_STEP_SUMMARY
        echo "2. Try the AI chatbot for interactive assistance" >> $GITHUB_STEP_SUMMARY
        echo "3. Add/modify files to see automatic documentation updates" >> $GITHUB_STEP_SUMMARY
        echo "4. Configure GitHub Models API key for enhanced AI features" >> $GITHUB_STEP_SUMMARY