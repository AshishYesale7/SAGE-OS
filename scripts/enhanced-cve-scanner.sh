#!/bin/bash

# Enhanced CVE Scanner for SAGE OS
# Author: Ashish Vasant Yesale <ashishyesale007@gmail.com>
# Version: 1.0.0
# Description: Comprehensive vulnerability scanner with multiple output formats

set -euo pipefail

# Script configuration
SCRIPT_NAME="Enhanced CVE Scanner"
SCRIPT_VERSION="1.0.0"
PROJECT_NAME="SAGE-OS"
PROJECT_VERSION="0.1.0"

# Default values
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
OUTPUT_DIR=""
ARCHITECTURES=""
FORMATS="console"
SCAN_DOCKER=true
SCAN_BINARIES=true
SCAN_SOURCE=true
VERBOSE=false
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
DEFAULT_OUTPUT_DIR="security-reports/scan_${TIMESTAMP}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_debug() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${PURPLE}[DEBUG]${NC} $1"
    fi
}

# Help function
show_help() {
    cat << EOF
${SCRIPT_NAME} v${SCRIPT_VERSION}
Comprehensive vulnerability scanner for SAGE OS project

USAGE:
    $0 [OPTIONS]

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Enable verbose output
    --version               Show version information
    
    PROJECT OPTIONS:
    --project-root DIR      Project root directory (default: auto-detected)
    --output-dir DIR        Output directory for reports (default: ${DEFAULT_OUTPUT_DIR})
    
    SCANNING OPTIONS:
    --arch ARCH             Scan specific architecture(s) (comma-separated)
                           Available: i386,x86_64,aarch64,arm,riscv64
                           Default: all available
    --no-docker             Skip Docker image scanning
    --no-binaries           Skip binary file scanning
    --no-source             Skip source code scanning
    --binary FILE           Scan specific binary file
    
    OUTPUT OPTIONS:
    --format FORMATS        Output format(s) (comma-separated)
                           Available: console,json,html,pdf,csv,xml
                           Default: console
    --summary-only          Generate summary report only
    
EXAMPLES:
    # Basic scan with console output
    $0
    
    # Scan specific architecture with multiple formats
    $0 --arch i386,x86_64 --format json,html,pdf
    
    # Comprehensive scan with all formats
    $0 --format console,json,html,pdf,csv,xml --verbose
    
    # Scan specific binary
    $0 --binary build/i386/kernel.img --format json
    
    # Quick summary scan
    $0 --summary-only --format html

REPORT STRUCTURE:
    The scanner creates versioned reports in the following structure:
    security-reports/
    └── scan_YYYYMMDD_HHMMSS/
        ├── summary.{format}
        ├── architecture_reports/
        │   ├── i386_vulnerabilities.{format}
        │   └── x86_64_vulnerabilities.{format}
        ├── docker_reports/
        │   └── sage-os_0.1.0-{arch}.{format}
        └── binary_reports/
            └── {binary_name}.{format}

VULNERABILITY LEVELS:
    CRITICAL    - Immediate action required
    HIGH        - High priority fixes needed
    MEDIUM      - Medium priority fixes recommended
    LOW         - Low priority, monitor for updates
    INFO        - Informational findings

EOF
}

# Version information
show_version() {
    cat << EOF
${SCRIPT_NAME} v${SCRIPT_VERSION}
Project: ${PROJECT_NAME} v${PROJECT_VERSION}
Author: Ashish Vasant Yesale <ashishyesale007@gmail.com>
License: MIT
EOF
}

# Detect system information
detect_system() {
    log_info "Detecting system information..."
    
    local os_name=$(uname -s)
    local os_version=$(uname -r)
    local arch=$(uname -m)
    
    log_debug "OS: $os_name $os_version"
    log_debug "Architecture: $arch"
    
    # Check for required tools
    local required_tools=("cve-bin-tool" "docker")
    local missing_tools=()
    
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" >/dev/null 2>&1; then
            missing_tools+=("$tool")
        fi
    done
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        log_warning "Missing tools: ${missing_tools[*]}"
        log_info "Installing missing tools..."
        
        for tool in "${missing_tools[@]}"; do
            case "$tool" in
                "cve-bin-tool")
                    pip3 install cve-bin-tool >/dev/null 2>&1 || {
                        log_error "Failed to install cve-bin-tool"
                        return 1
                    }
                    ;;
                "docker")
                    log_warning "Docker not found. Docker image scanning will be skipped."
                    SCAN_DOCKER=false
                    ;;
            esac
        done
    fi
    
    log_success "System detection completed"
}

# Get available architectures
get_available_architectures() {
    local archs=()
    
    # Check build directories
    if [ -d "$PROJECT_ROOT/build" ]; then
        for arch_dir in "$PROJECT_ROOT/build"/*; do
            if [ -d "$arch_dir" ]; then
                archs+=($(basename "$arch_dir"))
            fi
        done
    fi
    
    # Check dist directories
    if [ -d "$PROJECT_ROOT/dist" ]; then
        for arch_dir in "$PROJECT_ROOT/dist"/*; do
            if [ -d "$arch_dir" ]; then
                local arch=$(basename "$arch_dir")
                if [[ ! " ${archs[@]} " =~ " ${arch} " ]]; then
                    archs+=("$arch")
                fi
            fi
        done
    fi
    
    # Check build-output files
    if [ -d "$PROJECT_ROOT/build-output" ]; then
        for file in "$PROJECT_ROOT/build-output"/*.img; do
            if [ -f "$file" ]; then
                local filename=$(basename "$file")
                if [[ "$filename" =~ SAGE-OS-[0-9.]+-([^-]+)- ]]; then
                    local arch="${BASH_REMATCH[1]}"
                    if [[ ! " ${archs[@]} " =~ " ${arch} " ]]; then
                        archs+=("$arch")
                    fi
                fi
            fi
        done
    fi
    
    echo "${archs[@]}"
}

# Create output directory structure
create_output_structure() {
    local output_dir="$1"
    
    log_info "Creating output directory structure: $output_dir"
    
    mkdir -p "$output_dir"
    mkdir -p "$output_dir/architecture_reports"
    mkdir -p "$output_dir/docker_reports"
    mkdir -p "$output_dir/binary_reports"
    mkdir -p "$output_dir/source_reports"
    
    # Create metadata file
    cat > "$output_dir/scan_metadata.json" << EOF
{
    "scan_timestamp": "$(date -Iseconds)",
    "scanner_version": "$SCRIPT_VERSION",
    "project_name": "$PROJECT_NAME",
    "project_version": "$PROJECT_VERSION",
    "project_root": "$PROJECT_ROOT",
    "scan_configuration": {
        "architectures": "$ARCHITECTURES",
        "formats": "$FORMATS",
        "scan_docker": $SCAN_DOCKER,
        "scan_binaries": $SCAN_BINARIES,
        "scan_source": $SCAN_SOURCE
    }
}
EOF
    
    log_success "Output directory structure created"
}

# Scan binary file
scan_binary() {
    local binary_file="$1"
    local output_dir="$2"
    local formats="$3"
    
    if [ ! -f "$binary_file" ]; then
        log_warning "Binary file not found: $binary_file"
        return 1
    fi
    
    local binary_name=$(basename "$binary_file")
    log_info "Scanning binary: $binary_name"
    
    # Create temporary directory for this scan
    local temp_dir=$(mktemp -d)
    local base_output="$output_dir/binary_reports/${binary_name%.*}"
    
    # Run cve-bin-tool scan
    log_debug "Running cve-bin-tool on $binary_file"
    
    IFS=',' read -ra format_array <<< "$formats"
    for format in "${format_array[@]}"; do
        case "$format" in
            "console")
                cve-bin-tool "$binary_file" > "${base_output}.txt" 2>/dev/null || true
                ;;
            "json")
                cve-bin-tool --format json --output-file "${base_output}.json" "$binary_file" 2>/dev/null || true
                ;;
            "html")
                cve-bin-tool --format html --output-file "${base_output}.html" "$binary_file" 2>/dev/null || true
                ;;
            "csv")
                cve-bin-tool --format csv --output-file "${base_output}.csv" "$binary_file" 2>/dev/null || true
                ;;
            "pdf")
                # Generate HTML first, then convert to PDF if possible
                cve-bin-tool --format html --output-file "${temp_dir}/temp.html" "$binary_file" 2>/dev/null || true
                if command -v wkhtmltopdf >/dev/null 2>&1; then
                    wkhtmltopdf "${temp_dir}/temp.html" "${base_output}.pdf" 2>/dev/null || true
                else
                    log_warning "wkhtmltopdf not found, skipping PDF generation for $binary_name"
                fi
                ;;
            "xml")
                # Convert JSON to XML if possible
                if cve-bin-tool --format json --output-file "${temp_dir}/temp.json" "$binary_file" 2>/dev/null; then
                    if command -v python3 >/dev/null 2>&1; then
                        python3 -c "
import json, xml.etree.ElementTree as ET
with open('${temp_dir}/temp.json', 'r') as f:
    data = json.load(f)
root = ET.Element('cve_report')
for key, value in data.items():
    elem = ET.SubElement(root, key)
    elem.text = str(value)
tree = ET.ElementTree(root)
tree.write('${base_output}.xml')
" 2>/dev/null || true
                    fi
                fi
                ;;
        esac
    done
    
    # Cleanup
    rm -rf "$temp_dir"
    
    log_success "Binary scan completed: $binary_name"
}

# Scan architecture
scan_architecture() {
    local arch="$1"
    local output_dir="$2"
    local formats="$3"
    
    log_info "Scanning architecture: $arch"
    
    local arch_files=()
    
    # Find files for this architecture
    if [ -d "$PROJECT_ROOT/build/$arch" ]; then
        while IFS= read -r -d '' file; do
            arch_files+=("$file")
        done < <(find "$PROJECT_ROOT/build/$arch" -name "*.img" -o -name "*.elf" -print0 2>/dev/null)
    fi
    
    if [ -d "$PROJECT_ROOT/dist/$arch" ]; then
        while IFS= read -r -d '' file; do
            arch_files+=("$file")
        done < <(find "$PROJECT_ROOT/dist/$arch" -name "*.img" -o -name "*.iso" -print0 2>/dev/null)
    fi
    
    # Check build-output for versioned files
    for file in "$PROJECT_ROOT/build-output"/*"$arch"*.img; do
        if [ -f "$file" ]; then
            arch_files+=("$file")
        fi
    done
    
    if [ ${#arch_files[@]} -eq 0 ]; then
        log_warning "No files found for architecture: $arch"
        return 1
    fi
    
    # Scan each file
    local vuln_count=0
    for file in "${arch_files[@]}"; do
        log_debug "Scanning file: $file"
        if scan_binary "$file" "$output_dir" "$formats"; then
            ((vuln_count++)) || true
        fi
    done
    
    log_success "Architecture scan completed: $arch ($vuln_count files scanned)"
}

# Scan Docker images
scan_docker_images() {
    local output_dir="$1"
    local formats="$2"
    
    if [ "$SCAN_DOCKER" != true ]; then
        log_info "Docker scanning disabled, skipping..."
        return 0
    fi
    
    log_info "Scanning Docker images..."
    
    # Find SAGE OS Docker images
    local images=($(docker images --format "table {{.Repository}}:{{.Tag}}" | grep -E "sage-os|SAGE-OS" | tail -n +2 || true))
    
    if [ ${#images[@]} -eq 0 ]; then
        log_warning "No SAGE OS Docker images found"
        return 1
    fi
    
    for image in "${images[@]}"; do
        log_info "Scanning Docker image: $image"
        
        local image_name=$(echo "$image" | tr ':/' '_')
        local base_output="$output_dir/docker_reports/$image_name"
        
        # Export image to tar for scanning
        local temp_dir=$(mktemp -d)
        docker save "$image" -o "$temp_dir/image.tar" 2>/dev/null || {
            log_warning "Failed to export Docker image: $image"
            rm -rf "$temp_dir"
            continue
        }
        
        # Scan the exported image
        IFS=',' read -ra format_array <<< "$formats"
        for format in "${format_array[@]}"; do
            case "$format" in
                "console")
                    cve-bin-tool "$temp_dir/image.tar" > "${base_output}.txt" 2>/dev/null || true
                    ;;
                "json")
                    cve-bin-tool --format json --output-file "${base_output}.json" "$temp_dir/image.tar" 2>/dev/null || true
                    ;;
                "html")
                    cve-bin-tool --format html --output-file "${base_output}.html" "$temp_dir/image.tar" 2>/dev/null || true
                    ;;
                "csv")
                    cve-bin-tool --format csv --output-file "${base_output}.csv" "$temp_dir/image.tar" 2>/dev/null || true
                    ;;
            esac
        done
        
        rm -rf "$temp_dir"
        log_success "Docker image scan completed: $image"
    done
}

# Generate summary report
generate_summary() {
    local output_dir="$1"
    local formats="$2"
    
    log_info "Generating summary report..."
    
    local total_files=0
    local total_vulnerabilities=0
    local critical_count=0
    local high_count=0
    local medium_count=0
    local low_count=0
    
    # Count files and vulnerabilities
    for report_dir in "$output_dir"/{architecture_reports,docker_reports,binary_reports}; do
        if [ -d "$report_dir" ]; then
            total_files=$((total_files + $(find "$report_dir" -name "*.json" | wc -l)))
        fi
    done
    
    # Create summary content
    local summary_content="# SAGE OS Security Scan Summary

**Scan Date:** $(date)
**Scanner Version:** $SCRIPT_VERSION
**Project:** $PROJECT_NAME v$PROJECT_VERSION

## Scan Statistics
- **Total Files Scanned:** $total_files
- **Total Vulnerabilities:** $total_vulnerabilities
- **Critical:** $critical_count
- **High:** $high_count  
- **Medium:** $medium_count
- **Low:** $low_count

## Architecture Coverage
"

    # Add architecture information
    if [ -d "$output_dir/architecture_reports" ]; then
        for arch_report in "$output_dir/architecture_reports"/*.json; do
            if [ -f "$arch_report" ]; then
                local arch_name=$(basename "$arch_report" .json)
                summary_content+="\n- **$arch_name:** Scanned"
            fi
        done
    fi
    
    summary_content+="\n\n## Docker Images"
    if [ -d "$output_dir/docker_reports" ]; then
        for docker_report in "$output_dir/docker_reports"/*.json; do
            if [ -f "$docker_report" ]; then
                local image_name=$(basename "$docker_report" .json)
                summary_content+="\n- **$image_name:** Scanned"
            fi
        done
    fi
    
    summary_content+="\n\n## Recommendations
1. Review all CRITICAL and HIGH severity vulnerabilities immediately
2. Plan fixes for MEDIUM severity issues in next release cycle
3. Monitor LOW severity issues for updates
4. Regular security scans recommended (weekly/monthly)

## Report Files
This scan generated reports in the following formats: $formats

For detailed vulnerability information, check the individual report files in:
- \`architecture_reports/\` - Per-architecture vulnerability reports
- \`docker_reports/\` - Docker image vulnerability reports  
- \`binary_reports/\` - Individual binary file reports
"

    # Generate summary in requested formats
    IFS=',' read -ra format_array <<< "$formats"
    for format in "${format_array[@]}"; do
        case "$format" in
            "console"|"txt")
                echo -e "$summary_content" > "$output_dir/summary.txt"
                ;;
            "html")
                echo -e "$summary_content" | sed 's/^# /\<h1\>/g; s/^## /\<h2\>/g; s/^### /\<h3\>/g; s/^\*\*/\<strong\>/g; s/\*\*/\<\/strong\>/g' > "$output_dir/summary.html"
                ;;
            "json")
                cat > "$output_dir/summary.json" << EOF
{
    "scan_date": "$(date -Iseconds)",
    "scanner_version": "$SCRIPT_VERSION",
    "project": "$PROJECT_NAME",
    "project_version": "$PROJECT_VERSION",
    "statistics": {
        "total_files": $total_files,
        "total_vulnerabilities": $total_vulnerabilities,
        "critical": $critical_count,
        "high": $high_count,
        "medium": $medium_count,
        "low": $low_count
    }
}
EOF
                ;;
        esac
    done
    
    log_success "Summary report generated"
}

# Main scanning function
run_scan() {
    log_info "Starting comprehensive security scan..."
    log_info "Project: $PROJECT_NAME v$PROJECT_VERSION"
    log_info "Output directory: $OUTPUT_DIR"
    log_info "Formats: $FORMATS"
    
    # Detect system and install dependencies
    detect_system
    
    # Create output directory structure
    create_output_structure "$OUTPUT_DIR"
    
    # Get architectures to scan
    local available_archs=($(get_available_architectures))
    local scan_archs=()
    
    if [ -n "$ARCHITECTURES" ]; then
        IFS=',' read -ra requested_archs <<< "$ARCHITECTURES"
        for arch in "${requested_archs[@]}"; do
            if [[ " ${available_archs[@]} " =~ " ${arch} " ]]; then
                scan_archs+=("$arch")
            else
                log_warning "Architecture not available: $arch"
            fi
        done
    else
        scan_archs=("${available_archs[@]}")
    fi
    
    log_info "Scanning architectures: ${scan_archs[*]}"
    
    # Scan each architecture
    if [ "$SCAN_BINARIES" = true ]; then
        for arch in "${scan_archs[@]}"; do
            scan_architecture "$arch" "$OUTPUT_DIR" "$FORMATS"
        done
    fi
    
    # Scan Docker images
    scan_docker_images "$OUTPUT_DIR" "$FORMATS"
    
    # Generate summary
    generate_summary "$OUTPUT_DIR" "$FORMATS"
    
    log_success "Security scan completed successfully!"
    log_info "Reports available in: $OUTPUT_DIR"
    
    # Show quick summary
    echo
    echo "=== SCAN SUMMARY ==="
    if [ -f "$OUTPUT_DIR/summary.txt" ]; then
        head -20 "$OUTPUT_DIR/summary.txt"
    fi
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --project-root)
                PROJECT_ROOT="$2"
                shift 2
                ;;
            --output-dir)
                OUTPUT_DIR="$2"
                shift 2
                ;;
            --arch)
                ARCHITECTURES="$2"
                shift 2
                ;;
            --format)
                FORMATS="$2"
                shift 2
                ;;
            --no-docker)
                SCAN_DOCKER=false
                shift
                ;;
            --no-binaries)
                SCAN_BINARIES=false
                shift
                ;;
            --no-source)
                SCAN_SOURCE=false
                shift
                ;;
            --binary)
                # Scan specific binary
                if [ -z "$OUTPUT_DIR" ]; then
                    OUTPUT_DIR="$DEFAULT_OUTPUT_DIR"
                fi
                create_output_structure "$OUTPUT_DIR"
                scan_binary "$2" "$OUTPUT_DIR" "$FORMATS"
                exit 0
                ;;
            --summary-only)
                # Generate summary only
                if [ -z "$OUTPUT_DIR" ]; then
                    OUTPUT_DIR="$DEFAULT_OUTPUT_DIR"
                fi
                create_output_structure "$OUTPUT_DIR"
                generate_summary "$OUTPUT_DIR" "$FORMATS"
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                echo "Use --help for usage information"
                exit 1
                ;;
        esac
    done
}

# Main function
main() {
    # Set default output directory if not specified
    if [ -z "$OUTPUT_DIR" ]; then
        OUTPUT_DIR="$DEFAULT_OUTPUT_DIR"
    fi
    
    # Validate project root
    if [ ! -d "$PROJECT_ROOT" ]; then
        log_error "Project root directory not found: $PROJECT_ROOT"
        exit 1
    fi
    
    # Change to project root
    cd "$PROJECT_ROOT"
    
    # Run the scan
    run_scan
}

# Script entry point
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    parse_arguments "$@"
    main
fi